<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%= htmlWebpackPlugin.options.title %></title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate-path@2.3.0/build/d3-interpolate-path.js"></script>
    <link rel="stylesheet" href="./static/css/index.css" />
</head>

<body>
    <div id="app"></div>
    <template id="home-view">
        <home-view></home-view>
    </template>
    <template id="sample-view">
        <sample-view></sample-view>
    </template>
    <template id="heapsort-view">
        <heapsort-view popup-template-id="heapsort-popup-content"></heapsort-view>
    </template>
    <template id="dijkstra-view">
        <dijkstra-view popup-template-id="dijkstra-popup-content" control-template-id="graph-control-explanations">
        </dijkstra-view>
    </template>
    <template id="quicksort-view">
        <quicksort-view popup-template-id="quicksort-popup-content" control-template-id="graph-control-explanations">
        </quicksort-view>
    </template>
    <template id="astar-view">
        <astar-view popup-template-id="astar-popup-content" control-template-id="aStar-control-explanations">
        </astar-view>
    </template>
    <template id="linked-list-view">
        <linked-list-view popup-template-id="linked-list-popup-content"></linked-list-view>
    </template>
    <template id="linked-list-popup-content">
        <h2>Singly Linked List Visualization</h2>
        <h3>General</h3>
        <p>
            This is an interactive visualization of the data structure Singly Linked List Visualization. On the left
            side is the control panel
            where all the methods can be executed. Below that is the pseudocode for the class definitions. <br />
            On the right side is the visualization of the Singly Linked List. Each Node is represented as a rectangle
            and points to the next Node
            in the list. The last Node points to null. The first Node is the head. Below that the pseudocode for the
            currently executed method is
            shown. <br />
            The slider and the buttons at the bottom as well as the arrow keys can be used to step through the methods
            that were executed on the
            list.
        </p>
        <h3>The Singly Linked List</h3>
        <h4>General Information <sup>1</sup></h4>
        <p>
            A singly linked list is a type of linked list that is <b>unidirectional</b>, that is, it can be traversed in
            only one direction from
            head to the last node (tail). Each element in a linked list is called a node. A single node contains data
            and a pointer to the next
            node which helps in maintaining the structure of the list.
        </p>
        <p>
            The first node is called the head; it points to the first node of the list and helps us access every other
            element in the list. The
            last node, also sometimes called the tail, points to NULL which helps us in determining when the list ends.
        </p>
        <h4>Searching for a Node <sup>1</sup></h4>
        <p>
            You can determine and retrieve a specific node either from the front, the end, or anywhere in the list. The
            worst case Time Complexity
            for retrieving a node from anywhere in the list is <b>O(n)</b>.
        </p>
        <h4>Adding a Node <sup>1</sup></h4>
        <p>
            You can add a node at the front, the end or anywhere in the linked list. The worst case Time Complexity for
            performing these
            operations is as follows:
        </p>
        <ul>
            <li>Add item to the front of the list: <b>O(1)</b></li>
            <li>Add item to the end of the list: <b>O(n)</b></li>
            <li>Add item anywhere in the list: <b>O(n)</b></li>
        </ul>
        <h4>Remove a Node <sup>1</sup></h4>
        <p>
            You can remove a node either from the front, the end or from anywhere in the list. The worst case Time
            Complexity for performing this
            operation is as follows:
        </p>
        <ul>
            <li>Remove item from the front of the list: <b>O(1)</b></li>
            <li>Remove item from the end of the list: <b>O(n)</b></li>
            <li>Remove item from anywhere in the list: <b>O(n)</b></li>
        </ul>
        <h4>Advantages of Linked Lists <sup>2</sup></h4>
        <ul>
            <li>
                <b>Dynamic data structure</b> – A linked list is a dynamic arrangement so it can grow and shrink at
                runtime by allocating and
                deallocating memory. So there is no need to give the initial size of the linked list.
            </li>
            <li>
                <b>Insertion and Deletion Operations</b> - Insertion and deletion operations are quite easier in the
                linked list. There is no need
                to shift elements after the insertion or deletion of an element only the address present in the next
                pointer needs to be updated.
            </li>
            <li>
                <b>Efficient for large data</b> – When working with large datasets linked lists play a crucial role as
                it can grow and shrink
                dynamically.
            </li>
        </ul>
        <h4>Disadvantages of Linked Lists <sup>2</sup></h4>
        <ul>
            <li>
                <b>Memory usage</b> – More memory is required in the linked list as compared to an array. Because in a
                linked list, a pointer is
                also required to store the address of the next element and it requires extra memory for itself.
            </li>
            <li>
                <b>Traversal</b> - In a Linked list traversal is more time-consuming as compared to an array. Direct
                access to an element is not
                possible in a linked list as in an array by index. For example, for accessing a node at position n, one
                has to traverse all the
                nodes before it.
            </li>
            <li>
                <b>Reverse Traversing</b> – In a singly linked list reverse traversing is not possible, but in the case
                of a doubly-linked list,
                it can be possible as it contains a pointer to the previously connected nodes with each node. For
                performing this extra memory is
                required for the back pointer hence, there is a wastage of memory.
            </li>
        </ul>
        <h4>Applications of Singly Linked Lists <sup>3</sup></h4>
        <ul>
            <li>The singly linked list is used to implement stack and queue.</li>
            <li>The undo or redo options, the back buttons, etc., are implemented using a singly linked list.</li>
            <li>
                During the implementation of a hash function, there arises a problem of collision, to deal with this
                problem, a singly linked list
                is used.
            </li>
        </ul>

        <p style="color: rgba(0, 0, 0, 0)">.</p>
        <p>
            <sup>1</sup> Explanations in this section are from: What is a singly linked list?. (n.d.). Educative.
            <a
                href="https://www.educative.io/answers/what-is-a-singly-linked-list">https://www.educative.io/answers/what-is-a-singly-linked-list</a>
            (last accessed: 20.03.2023)
        </p>
        <p>
            <sup>2</sup> Explanations in this section are from: Advantages and Disadvantages of Linked List. (2023,
            February 15). GeeksforGeeks.
            <a
                href="https://www.geeksforgeeks.org/advantages-and-disadvantages-of-linked-list/">https://www.geeksforgeeks.org/advantages-and-disadvantages-of-linked-list/</a>
            (last accessed: 20.03.2023)
        </p>
        <p>
            <sup>3</sup> Explanations in this section are from: What are the Applications of Linked List?. (n.d.).
            Interview Kickstart.
            <a
                href="https://www.scaler.com/topics/application-of-linked-list/">https://www.scaler.com/topics/application-of-linked-list/</a>
            (last accessed: 20.03.2023)
        </p>
    </template>
    <template id="heapsort-popup-content">
        <h2>Heapsort Visualization</h2>
        <h3>General</h3>
        <p>
            This is an interactive visualization of the Heapsort Algorithm. On the left side is the representation of
            the array. It can be changed
            by entering new data in the input field at the top left (e.g. 5,3,7,11,9,4,2). Below that the pseudocode for
            the algorithm is shown
            and the corresponding lines will be highlighted while stepping through the algorithm. <br />
            On the right side the data is shown in binary tree form where the root element is the first element of the
            array, the first child is
            the second element of the array, the second child is the third element of the array and so on. <br />
            The slider and the buttons at the bottom as well as the arrow keys can be used to step through the
            algorithm.
        </p>
        <h3>The Heapsort Algorithm</h3>
        <h4>General Information <sup>1</sup></h4>
        <p>
            Heapsort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the
            selection sort where we
            first find the minimum element and place the minimum element at the beginning. Repeat the same process for
            the remaining elements.
        </p>
        <ul>
            <li>Heap sort is an in-place algorithm.</li>
            <li>Its typical implementation is not stable, but can be made stable</li>
            <li>Typically 2-3 times slower than well-implemented QuickSort. The reason for slowness is a lack of
                locality of reference.</li>
        </ul>
        <h4>Steps <sup>1</sup></h4>
        <ul>
            <li>Build a max heap from the input data.</li>
            <li>
                At this point, the maximum element is stored at the root of the heap. Replace it with the last item of
                the heap followed by
                reducing the size of the heap by1. Finally, heapify the root of the tree.
            </li>
            <li>Repeat step 2 while the size of the heap is greater than 1.</li>
        </ul>
        <h4>What is meant by Heapify? <sup>1</sup></h4>
        <p>
            Heapify is the process of creating a heap data structure from a binary tree represented using an array. It
            is used to create Min-Heap
            or Max-heap. Start from the first index of the non-leaf node whose index is given by n/2 – 1. Heapify uses
            recursion.
        </p>
        <h4>Time Complexity <sup>2</sup></h4>
        <p>The time complexity of heap sort is non-quadratic and comes out the same in the best, worst and average
            cases: O(nlogn)</p>
        <ol>
            <li>The first step of heap sort, which is building a heap out of a randomly arranged array, can be done in
                <b>O(n)</b>.</li>
            <li>
                Swapping the max element with the bottom level right-most element and reducing the heap size can be done
                in constant time,
                <b>O(1)</b>.
            </li>
            <li>
                In the worst case, the new value at the root position will have to be swapped log(N) times to be sent to
                the bottom of the heap to
                achieve a MaxHeap once again. So each reheapification after the extraction costs <b>O(logN)</b>.
            </li>
        </ol>
        <p>
            Step 2 and 3 will be performed N times, so the total time complexity of getting a sorted array out of a
            MaxHeap is
            <b>O(N*log(N))</b>.<br />
            <br />
            We can calculate the total time complexity of heap sort as: <br />
            Time for creating a MaxHeap + Time for getting a sorted array out of a MaxHeap <br />
            <b>= O(N) + O(N*log(N))</b> <br />
            <b>= O(N*log(N))</b>
        </p>
        <h4>Advantages of Heapsort <sup>1</sup></h4>
        <ul>
            <li>
                <b>Efficiency</b> – The time required to perform Heap sort increases logarithmically while other
                algorithms may grow exponentially
                slower as the number of items to sort increases. This sorting algorithm is very efficient.
            </li>
            <li>
                <b>Memory Usage</b> - Memory usage is minimal because apart from what is necessary to hold the initial
                list of items to be sorted,
                it needs no additional space to work
            </li>
            <li>
                <b>Simplicity</b> – It is simpler to understand than other equally efficient sorting algorithms because
                it does not use advanced
                computer science concepts such as recursion
            </li>
        </ul>
        <h4>Disadvantages of Heapsort <sup>1</sup></h4>
        <ul>
            <li><b>Costly</b> – Heap sort is costly.</li>
            <li>
                <b>Unstable</b> - Heap sort is unstable. This algorithm is not stable because the operations that are
                performed in a heap can
                change the relative ordering of the equivalent keys.
            </li>
            <li><b>Efficient</b> – Heap Sort are not very efficient when working with highly complex data.</li>
        </ul>
        <h4>Applications of Heapsort <sup>1</sup></h4>
        <ul>
            <li>Heapsort is mainly used in hybrid algorithms like the IntroSort</li>
            <li>Sort a nearly sorted (or K sorted) array</li>
            <li>k largest(or smallest) elements in an array</li>
        </ul>
        <p>
            The heap sort algorithm has limited uses because Quicksort and Mergesort are better in practice.
            Nevertheless, the Heap data structure
            itself is enormously used.
        </p>
        <p style="color: rgba(0, 0, 0, 0)">.</p>
        <p>
            <sup>1</sup> Explanations in this section are from: Heap Sort. (2023, März 16). GeeksforGeeks.
            <a href="https://www.geeksforgeeks.org/heap-sort/">https://www.geeksforgeeks.org/heap-sort/</a> (last
            accessed: 20.03.2023)
        </p>
        <p>
            <sup>2</sup> Explanations in this section are from: Heap Sort Algorithm: Explanation, Implementation, and
            Complexity. (n.d.).
            Interview Kickstart.
            <a
                href="https://www.interviewkickstart.com/learn/heap-sort">https://www.interviewkickstart.com/learn/heap-sort</a>
            (last accessed:
            20.03.2023)
        </p>
    </template>

    <template id="dijkstra-popup-content">
        <h2>Dijkstra Visualization</h2>
        <h3>General</h3>
        <p>
            This is an interactive visualization of the Dijkstra Algorithm. On the left side is the graph which can be
            altered by adding and
            deleting nodes and edges. To start the algorithm, select a node as the starting node and press the start
            button. <br />
            The algorithm will then run and the table on the right side will be updated with the current shortest path
            to each node. The
            pseudocode shown below the table will highlight the corresponding lines of code. <br />
            The slider and the buttons at the bottom as well as the arrow keys can be used to step through the
            algorithm.
        </p>
        <h3>The Dijkstra Algorithm</h3>
        <h4>Purpose and Use Cases <sup>1</sup></h4>
        <p>
            With Dijkstra's Algorithm, you can find the shortest path between nodes in a graph. Particularly, you can
            find the shortest path from
            a node (called the "source node") to all other nodes in the graph, producing a shortest-path tree. This
            algorithm is used in GPS
            devices to find the shortest path between the current location and the destination. It has broad
            applications in industry, specially
            in domains that require modeling networks.
        </p>
        <h4>Basics <sup>1</sup></h4>
        <ul>
            <li>
                Dijkstra's Algorithm basically starts at the node that you choose (the source node) and it analyzes the
                graph to find the shortest
                path between that node and all the other nodes in the graph.
            </li>
            <li>
                The algorithm keeps track of the currently known shortest distance from each node to the source node and
                it updates these values
                if it finds a shorter path.
            </li>
            <li>
                Once the algorithm has found the shortest path between the source node and another node, that node is
                marked as "visited" and
                added to the path.
            </li>
            <li>
                The process continues until all the nodes in the graph have been added to the path. This way, we have a
                path that connects the
                source node to all other nodes following the shortest path possible to reach each node.
            </li>
        </ul>
        <h4>Requirements <sup>1</sup></h4>
        <p>
            Dijkstra's Algorithm can only work with graphs that have positive weights. This is because, during the
            process, the weights of the
            edges have to be added to find the shortest path. If there is a negative weight in the graph, then the
            algorithm will not work
            properly. Once a node has been marked as "visited", the current path to that node is marked as the shortest
            path to reach that node.
            And negative weights can alter this if the total weight can be decremented after this step has occurred.
        </p>
        <h4>Time Complexity <sup>2</sup></h4>
        <p>
            Time complexity of Dijkstra's algorithm is O(V<sup>2</sup>) where V is the number of vertices in the graph.
            It can be explained as
            below:
        </p>
        <ol>
            <li>
                First thing we need to do is find the unvisited vertex with the smallest path. For that we require O(V)
                time as we need check all
                the vertices.
            </li>
            <li>
                Now for each vertex selected as above, we need to relax its neighbours which means to update each
                neighbours path to the smaller
                value between its current path or to the newly found. The time required to relax one neighbour comes out
                to be of order of O(1)
                (constant time).
            </li>
            <li>
                For each vertex we need to relax all of its neighbours, and a vertex can have at most V-1 neighbours, so
                the time required to
                update all neighbours of a vertex comes out to be [O(V) * O(1)] = O(V)
            </li>
        </ol>
        <p>So now following the above conditions, we get:</p>
        <ul>
            <li>Time for visiting all vertices <b>= O(V)</b></li>
            <li>Time required for processing one vertex <b>= O(V)</b></li>
            <li>Time required for visiting and processing all the vertices <b>= O(V) * O(V) = O(V<sup>2</sup>)</b></li>
        </ul>
        <p style="color: rgba(0, 0, 0, 0)">.</p>
        <p>
            <sup>1</sup> Explanations in this section are from: Navone, E. C. (2020, September 28). Dijkstra’s Shortest
            Path Algorithm—A Detailed
            and Visual Introduction. FreeCodeCamp.Org.
            <a
                href="https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/">https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/</a>
            (last accessed: 20.03.2023)
        </p>
        <p>
            <sup>2</sup> Explanations in this section are from: Pandey, M. (2021, December 20). Dijkstra Algorithm.
            Scaler Topics.
            <a
                href="https://www.scaler.com/topics/data-structures/dijkstra-algorithm/">https://www.scaler.com/topics/data-structures/dijkstra-algorithm/</a>
            (last accessed: 20.03.2023)
        </p>
    </template>

    <template id="quicksort-popup-content">
        <h2>Quicksort Visualization</h2>
        <p>
            This is an interactive visualization of the Quicksort Algorithm. On the left side is the representation of
            the array. It can be changed
            by entering new data in the input field at the top left (e.g. 5,3,7,11,9,4,2). On the right, the pseudocode
            for the algorithm is shown
            and the corresponding lines will be highlighted while stepping through the algorithm. <br />
            The slider and the buttons at the bottom as well as the arrow keys can be used to step through the
            algorithm.
        </p>
        <h4>General Information <sup>1</sup></h4>
        <p>
            QuickSort is a sorting algorithm based on the Divide and Conquer algorithm that picks an element as a pivot
            and partitions the given array
            around the picked pivot by placing the pivot in its correct position in the sorted array.
        </p>
        <h4>Steps </h4>
        <ul>
            <li>Select a pivot element from the array.</li>
            <li>Rearrange the array so that elements smaller than the pivot are on the left, and elements larger than
                the pivot are on the right.</li>
            <li>Apply Quicksort recursively to the left and right partitions and combine the sorted partitions to get
                the final sorted array.</li>
        </ul>
        <h4>How does the partitioning work? <sup>1</sup></h4>
        <p>
            The target of partitions is to place the pivot (any element can be chosen to be a pivot) at its correct
            position in the sorted array and put
            all smaller elements to the left of the pivot, and all greater elements to the right of the pivot. <br> <br>
            There are different choices for picking pivots, which can result in different effiencies depending on the
            input data.
            <ul>
                <li>Always pick the last element as a pivot (implemented here)</li>
                <li>Always pick the first element as a pivot</li>
                <li>Pick a random element as a pivot.</li>
                <li>Pick the middle as the pivot.</li>
            </ul>
        </p>
        <h4>Time Complexity <sup>2</sup></h4>
        <ul>
            <li>
                <b>Best case: O(n*logn) </b><br>
                This happens if we pick the median of the array as the pivot element every time. The size of subarrays
                will be half the size of the
                original array.
            </li>
            <li>
                <b>Worst case: O(n^2) </b><br>
                This happens if we pick the largest or the smallest element of the array as the pivot element every
                time. The size of the subarray
                after partitioning will be n-1 and 1.
            </li>
            <li>
                <b>Average case: O(n*logn) </b><br>
                This is the average time taken for all n! permutations of n elements.
            </li>
        </ul>
        <h4>Advantages of Quicksort <sup>1</sup></h4>
        <ul>
            <li>
                <b>Easier to solve problems</b>, because it is a divide-and-conquer algorithm
            </li>
            <li>
                <b>Efficient</b> on <b>large</b> data sets
            </li>
            <li>
                <b>Low overhead</b>, as it only requires a small amount of memory to function
            </li>
        </ul>
        <h4>Disadvantages of Quicksort <sup>1</sup></h4>
        <ul>
            <li> <b>Worst-case time complexity of O(N<sup>2</sup>)</b>, which occurs when the pivot is chosen poorly
            </li>
            <li> <b>Inefficient</b> on <b>small</b> data sets </li>
            <li>
                <b>Not stable</b>, meaning that if two elements have the same key, their relative order will not be
                preserved in the sorted output
                in case of quick sort, because here we are swapping elements according to the pivot's position (without
                considering their original positions)
            </li>
        </ul>
        <p style="color: rgba(0, 0, 0, 0)">.</p>
        <p>
            <sup>1</sup> Explanations in this section are from: Quicksort. (2023, August 09). GeeksforGeeks.
            <a href="https://www.geeksforgeeks.org/quick-sort/">https://www.geeksforgeeks.org/quick-sort/</a> (last
            accessed: 16.08.2023)
        </p>
        <p>
            <sup>2</sup> Explanations in this section are from: Quick Sort Algorithm: Explanation, Implementation, and
            Complexity. (2023, August 08).
            Interview Kickstart.
            <a
                href="https://www.interviewkickstart.com/learn/quick-sort">https://www.interviewkickstart.com/learn/quick-sort</a>
            (last accessed:
            16.08.2023)
        </p>
    </template>

    <template id="astar-popup-content">
        <h2>A* Visualization</h2>
        <h3>General</h3>
        <p>
            This is an interactive visualization of the A* Algorithm. On the left side is the graph which can be altered
            by adding and
            deleting nodes and edges. To start the algorithm, left click on a node to select a starting node, right
            click on a node to
            select and ending Node and press the start button. <br />
            The algorithm will then run and the table on the right side will be updated with the current shortest path
            to each node and
            its corresponding heuristic, which is both are used to determine the next node to visit. The pseudocode
            shown below the table
            will highlight the corresponding lines of code. <br />
            The slider and the buttons at the bottom as well as the arrow keys can be used to step through the
            algorithm.
        </p>
        <h3>The A* Algorithm</h3>
        <h4>Purpose and Use Cases <sup>1</sup></h4>
        <p>
            A* is a searching algorithm that is used to find the shortest path between a start and an end node. It is an
            extension of Dijkstra's
            shortest path algorithm. The extension here is that we use a heuristic function that provides additional
            information regarding how far
            away from the goal node we are. The A* algorithm is widely used in various domains for pathfinding and
            optimization problems. It has
            applications in robotics, video games, route planning, logistics, and artificial intelligence. In robotics,
            A* helps robots navigate
            obstacles and find optimal paths. In video games, it enables NPCs to navigate game environments
            intelligently. Route planning applications
            use A* to find the shortest or fastest routes between locations. Logistics industries utilize A* for vehicle
            routing and scheduling. A* is
            also employed in AI systems, such as natural language processing and machine learning, to optimize
            decision-making processes.
        </p>
        <h4>Basics <sup>1</sup></h4>
        <ul>
            <li>
                A* basically starts at the node that you choose (the start node) and it analyzes the graph to find the
                shortest
                path between that node and the end node.
            </li>
            <li>
                The algorithm keeps track of the currently known shortest distance from each node to the start node and
                it updates these values
                if it finds a shorter path.
            </li>
            <li>
                At each step, it picks the node with the smallest value of f (the sum of g and h) and processes that
                node.
            </li>
            <li>
                g and h are defined as:
            </li>
            <ul>
                <li>
                    g is the the currently known shortest distance from a node to the start node and the value gets
                    updated if the algorithm finds
                    a shorter path.
                </li>
                <li>
                    h is the heuristic, which is the estimation of the distance from a node to the end node. This
                    implementation uses the euclidian
                    distance, which is used very commonly, as well as the manhattan distance.
                </li>
            </ul>
            <li>
                Processing the node means, that the Algorithm calculates the cost to all of the nodes immediate
                neighboring nodes and chooses the one
                incurring the least cost.
            </li>
            <li>
                The process continues until we have reached the end node, so that we have found the shortest path to it
                or at least the path with the
                lowest cost.
            </li>
        </ul>
        <h4>Requirements <sup>2</sup></h4>
        <p>
            A*'s Algorithm can only work with graphs that have positive weights. This is because, during the process,
            the weights of the
            edges have to be added to find the shortest path. If there is a negative weight in the graph, then the
            algorithm will not work
            properly. Once a node has been marked as "visited", the current path to that node is marked as the shortest
            path to reach that node.
            And negative weights can alter this if the total weight can be decremented after this step has occurred.
        </p>
        <h4>Time Complexity</h4>
        <p>
            The time complexity of the A* algorithm is influenced by several factors, including the characteristics of
            the graph, the heuristics
            used, and the data structures employed. In its worst-case scenario, A* has a time complexity of
            <b>O(V<sup>2</sup>)</b>, where V is
            the number of vertices in the graph. This can be explained as follows:
        </p>
        <ol>
            <li>
                First, we need to find the unvisited vertex with the smallest estimated total cost (heuristic + actual
                cost) to reach the end node.
                This requires sorting the unvisited vertices based on their estimated total cost, which takes <b>O(V log
                    V)</b> time using efficient
                data structures like binary heaps.
            </li>
            <li>
                For each selected vertex, we need to relax its neighbors, updating their shortest distance and total
                cost values. This involves
                iterating through the neighbors and performing constant-time updates, which takes <b>O(V)</b> time.
            </li>
        </ol>
        <p>Considering the above conditions, we get:</p>
        <ul>
            <li>Time for selecting the vertex with the smallest estimated total cost <b>= O(V log V)</b></li>
            <li>Time required for relaxing neighbors for each selected vertex <b>= O(V)</b></li>
            <li>Overall time complexity <b>= O(V log V) * O(V) = O(V<sup>2</sup> log V)</b></li>
        </ul>
        <p>
            However, in practice, with proper data structures and effective heuristics, the A* algorithm can often
            achieve significantly better
            performance than its worst-case time complexity suggests.
        </p>
        Please note that the provided code snippet is not an exact match for the pseudocode you mentioned earlier, so
        I've provided a general
        explanation of the time complexity that fits the A* algorithm logic in your code.
        <p style="color: rgba(0, 0, 0, 0)">.</p>
        <p>
            <sup>1</sup> Explanations in this section are from: Ravikiran A S (2023, August 9). A* Algorithm Concepts
            and Implementation
            <a
                href="https://www.simplilearn.com/tutorials/artificial-intelligence-tutorial/a-star-algorithm">https://www.simplilearn.com/tutorials/artificial-intelligence-tutorial/a-star-algorithm</a>
            (last accessed: 10.08.2023)
        </p>
        <p>
            <sup>2</sup> Explanations in this section are from: Navone, E. C. (2020, September 28). Dijkstra’s Shortest
            Path Algorithm—A Detailed
            and Visual Introduction. FreeCodeCamp.Org.
            <a
                href="https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/">https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/</a>
            (last accessed: 10.08.2023)
        </p>
    </template>

    <template id="graph-control-explanations">
        <style>
            p {
                margin: 0 0 5px 0;
            }

            b {
                margin: 0 8px 5px 0;
            }

            kbd {
                background-color: #eee;
                border-radius: 3px;
                border: 1px solid #b4b4b4;
                box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2), 0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
                color: #333;
                display: inline-block;
                font-size: 0.85em;
                font-weight: 700;
                line-height: 1;
                padding: 2px 4px;
                white-space: nowrap;
            }
        </style>
        <b>Select a startnode:</b>
        <p>Click on a node until the color changes</p>
        <b>Add a Node:</b>
        <p>Hold <kbd>Shift</kbd> and click on the canvas</p>
        <b>Delete a Node:</b>
        <p>Select a node and press <kbd>← Backspace</kbd> or <kbd>Delete</kbd></p>
        <b>Add an Edge:</b>
        <p>
            Hold <kbd>Shift</kbd> and drag from one node to another node, to add an undirected edge add a second edge in
            the other direction
            between the nodes
        </p>
        <b>Change Edge Weight:</b>
        <p>Hold <kbd>Shift</kbd> and click on an edge</p>
        <b>Delete an Edge:</b>
        <p>Select an edge and press <kbd>← Backspace</kbd> or <kbd>Delete</kbd></p>
    </template>

    <template id="aStar-control-explanations">
        <style>
            p {
                margin: 0 0 5px 0;
            }

            b {
                margin: 0 8px 5px 0;
            }

            kbd {
                background-color: #eee;
                border-radius: 3px;
                border: 1px solid #b4b4b4;
                box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2), 0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
                color: #333;
                display: inline-block;
                font-size: 0.85em;
                font-weight: 700;
                line-height: 1;
                padding: 2px 4px;
                white-space: nowrap;
            }
        </style>
        <b>Select a startnode:</b>
        <p>Click on a node until the color changes</p>
        <b>Select an endnode:</b>
        <p>Right click on a node until the color changes</p>
        <b>Add a Node:</b>
        <p>Hold <kbd>Shift</kbd> and click on the canvas</p>
        <b>Delete a Node:</b>
        <p>Select a node and press <kbd>← Backspace</kbd> or <kbd>Delete</kbd></p>
        <b>Add an Edge:</b>
        <p>
            Hold <kbd>Shift</kbd> and drag from one node to another node, to add an undirected edge add a second edge in
            the other direction
            between the nodes
        </p>
        <b>Change Edge Weight:</b>
        <p>Hold <kbd>Shift</kbd> and click on an edge</p>
        <b>Delete an Edge:</b>
        <p>Select an edge and press <kbd>← Backspace</kbd> or <kbd>Delete</kbd></p>
    </template>
</body>

</html>