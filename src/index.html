<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Algorithm Visualizer</title>

        <script src="/static/js/mixins/wait-mixin.js"></script>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-interpolate-path@2.3.0/build/d3-interpolate-path.js"></script>
        <link rel="stylesheet" href="/static/css/index.css" />

        <script src="/static/js/views/HeapsortView.js"></script>
        <script src="/static/js/views/DijkstraView.js"></script>
        <script src="/static/js/views/LinkedListView.js"></script>
        <script src="/static/js/views/HomeView.js"></script>
        <script src="/static/js/components/Header.js"></script>
        <script src="/static/js/components/ProgressBar.js"></script>
        <script src="/static/js/components/ArrayDisplay.js"></script>
        <script src="/static/js/components/BinaryTree.js"></script>
        <script src="/static/js/components/PopUp.js"></script>
        <script src="/static/js/components/TableDisplay.js"></script>
        <script src="/static/js/components/PseudocodeDisplay.js"></script>
        <script src="/static/js/components/GraphCreator.js"></script>
        <script src="/static/js/components/LinkedList.js"></script>
        <script src="/static/js/components/SplitLayout.js"></script>
        <script src="/static/js/components/VisContainer.js"></script>
        <script src="/static/js/components/ControlPanel.js"></script>
        <script src="/static/js/components/CategoryCard.js"></script>
        <script src="/static/js/components/NavItem.js"></script>
        <script src="/static/js/components/VisControl.js"></script>
    </head>
    <body>
        <div id="app"></div>
        <template id="home-view">
            <home-view></home-view>
        </template>
        <template id="heapsort-view">
            <heapsort-view popup-template-id="heapsort-popup-content"></heapsort-view>
        </template>
        <template id="dijkstra-view">
            <dijkstra-view popup-template-id="dijkstra-popup-content" control-template-id="graph-control-explanations"></dijkstra-view>
        </template>
        <template id="linked-list-view">
            <linked-list-view popup-template-id="linked-list-popup-content"></linked-list-view>
        </template>
        <template id="linked-list-popup-content">
            <h2>Singly Linked List Visualization</h2>
            <h3>General</h3>
            <p>
                This is an interactive visualization of the data structure Singly Linked List Visualization. On the left side is the control panel
                where all the methods can be executed. Below that is the pseudocode for the class definitions. <br />
                On the right side is the visualization of the Singly Linked List. Each Node is represented as a rectangle and points to the next Node
                in the list. The last Node points to null. The first Node is the head. Below that the pseudocode for the currently executed method is
                shown. <br />
                The slider and the buttons at the bottom as well as the arrow keys can be used to step through the methods that were executed on the
                list.
            </p>
            <h3>The Singly Linked List</h3>
            <h4>General Information <sup>1</sup></h4>
            <p>
                A singly linked list is a type of linked list that is <b>unidirectional</b>, that is, it can be traversed in only one direction from
                head to the last node (tail). Each element in a linked list is called a node. A single node contains data and a pointer to the next
                node which helps in maintaining the structure of the list.
            </p>
            <p>
                The first node is called the head; it points to the first node of the list and helps us access every other element in the list. The
                last node, also sometimes called the tail, points to NULL which helps us in determining when the list ends.
            </p>
            <h4>Searching for a Node <sup>1</sup></h4>
            <p>
                You can determine and retrieve a specific node either from the front, the end, or anywhere in the list. The worst case Time Complexity
                for retrieving a node from anywhere in the list is <b>O(n)</b>.
            </p>
            <h4>Adding a Node <sup>1</sup></h4>
            <p>
                You can add a node at the front, the end or anywhere in the linked list. The worst case Time Complexity for performing these
                operations is as follows:
            </p>
            <ul>
                <li>Add item to the front of the list: <b>O(1)</b></li>
                <li>Add item to the end of the list: <b>O(n)</b></li>
                <li>Add item anywhere in the list: <b>O(n)</b></li>
            </ul>
            <h4>Remove a Node <sup>1</sup></h4>
            <p>
                You can remove a node either from the front, the end or from anywhere in the list. The worst case Time Complexity for performing this
                operation is as follows:
            </p>
            <ul>
                <li>Remove item from the front of the list: <b>O(1)</b></li>
                <li>Remove item from the end of the list: <b>O(n)</b></li>
                <li>Remove item from anywhere in the list: <b>O(n)</b></li>
            </ul>
            <h4>Advantages of Linked Lists <sup>2</sup></h4>
            <ul>
                <li>
                    <b>Dynamic data structure</b> – A linked list is a dynamic arrangement so it can grow and shrink at runtime by allocating and
                    deallocating memory. So there is no need to give the initial size of the linked list.
                </li>
                <li>
                    <b>Insertion and Deletion Operations</b> - Insertion and deletion operations are quite easier in the linked list. There is no need
                    to shift elements after the insertion or deletion of an element only the address present in the next pointer needs to be updated.
                </li>
                <li>
                    <b>Efficient for large data</b> – When working with large datasets linked lists play a crucial role as it can grow and shrink
                    dynamically.
                </li>
            </ul>
            <h4>Disadvantages of Linked Lists <sup>2</sup></h4>
            <ul>
                <li>
                    <b>Memory usage</b> – More memory is required in the linked list as compared to an array. Because in a linked list, a pointer is
                    also required to store the address of the next element and it requires extra memory for itself.
                </li>
                <li>
                    <b>Traversal</b> - In a Linked list traversal is more time-consuming as compared to an array. Direct access to an element is not
                    possible in a linked list as in an array by index. For example, for accessing a node at position n, one has to traverse all the
                    nodes before it.
                </li>
                <li>
                    <b>Reverse Traversing</b> – In a singly linked list reverse traversing is not possible, but in the case of a doubly-linked list,
                    it can be possible as it contains a pointer to the previously connected nodes with each node. For performing this extra memory is
                    required for the back pointer hence, there is a wastage of memory.
                </li>
            </ul>
            <h4>Applications of Singly Linked Lists <sup>3</sup></h4>
            <ul>
                <li>The singly linked list is used to implement stack and queue.</li>
                <li>The undo or redo options, the back buttons, etc., are implemented using a singly linked list.</li>
                <li>
                    During the implementation of a hash function, there arises a problem of collision, to deal with this problem, a singly linked list
                    is used.
                </li>
            </ul>

            <p style="color: rgba(0, 0, 0, 0)">.</p>
            <p>
                <sup>1</sup> Explanations in this section are from: What is a singly linked list?. (n.d.). Educative.
                <a href="https://www.educative.io/answers/what-is-a-singly-linked-list"
                    >https://www.educative.io/answers/what-is-a-singly-linked-list</a
                >
                (last accessed: 20.03.2023)
            </p>
            <p>
                <sup>2</sup> Explanations in this section are from: Advantages and Disadvantages of Linked List. (2023, February 15). GeeksforGeeks.
                <a href="https://www.geeksforgeeks.org/advantages-and-disadvantages-of-linked-list/"
                    >https://www.geeksforgeeks.org/advantages-and-disadvantages-of-linked-list/</a
                >
                (last accessed: 20.03.2023)
            </p>
            <p>
                <sup>3</sup> Explanations in this section are from: What are the Applications of Linked List?. (n.d.). Interview Kickstart.
                <a href="https://www.scaler.com/topics/application-of-linked-list/">https://www.scaler.com/topics/application-of-linked-list/</a>
                (last accessed: 20.03.2023)
            </p>
        </template>
        <template id="heapsort-popup-content">
            <h2>Heapsort Visualization</h2>
            <h3>General</h3>
            <p>
                This is an interactive visualization of the Heapsort Algorithm. On the left side is the representation of the array. It can be changed
                by entering new data in the input field at the top left (e.g. 5,3,7,11,9,4,2). Below that the pseudocode for the algorithm is shown
                and the corresponding lines will be highlighted while stepping through the algorithm. <br />
                On the right side the data is shown in binary tree form where the root element is the first element of the array, the first child is
                the second element of the array, the second child is the third element of the array and so on. <br />
                The slider and the buttons at the bottom as well as the arrow keys can be used to step through the algorithm.
            </p>
            <h3>The Heapsort Algorithm</h3>
            <h4>General Information <sup>1</sup></h4>
            <p>
                Heapsort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we
                first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.
            </p>
            <ul>
                <li>Heap sort is an in-place algorithm.</li>
                <li>Its typical implementation is not stable, but can be made stable</li>
                <li>Typically 2-3 times slower than well-implemented QuickSort. The reason for slowness is a lack of locality of reference.</li>
            </ul>
            <h4>Steps <sup>1</sup></h4>
            <ul>
                <li>Build a max heap from the input data.</li>
                <li>
                    At this point, the maximum element is stored at the root of the heap. Replace it with the last item of the heap followed by
                    reducing the size of the heap by1. Finally, heapify the root of the tree.
                </li>
                <li>Repeat step 2 while the size of the heap is greater than 1.</li>
            </ul>
            <h4>What is meant by Heapify? <sup>1</sup></h4>
            <p>
                Heapify is the process of creating a heap data structure from a binary tree represented using an array. It is used to create Min-Heap
                or Max-heap. Start from the first index of the non-leaf node whose index is given by n/2 – 1. Heapify uses recursion.
            </p>
            <h4>Time Complexity <sup>2</sup></h4>
            <p>The time complexity of heap sort is non-quadratic and comes out the same in the best, worst and average cases: O(nlogn)</p>
            <ol>
                <li>The first step of heap sort, which is building a heap out of a randomly arranged array, can be done in <b>O(n)</b>.</li>
                <li>
                    Swapping the max element with the bottom level right-most element and reducing the heap size can be done in constant time,
                    <b>O(1)</b>.
                </li>
                <li>
                    In the worst case, the new value at the root position will have to be swapped log(N) times to be sent to the bottom of the heap to
                    achieve a MaxHeap once again. So each reheapification after the extraction costs <b>O(logN)</b>.
                </li>
            </ol>
            <p>
                Step 2 and 3 will be performed N times, so the total time complexity of getting a sorted array out of a MaxHeap is
                <b>O(N*log(N))</b>.<br />
                <br />
                We can calculate the total time complexity of heap sort as: <br />
                Time for creating a MaxHeap + Time for getting a sorted array out of a MaxHeap <br />
                <b>= O(N) + O(N*log(N))</b> <br />
                <b>= O(N*log(N))</b>
            </p>
            <h4>Advantages of Heapsort <sup>1</sup></h4>
            <ul>
                <li>
                    <b>Efficiency</b> – The time required to perform Heap sort increases logarithmically while other algorithms may grow exponentially
                    slower as the number of items to sort increases. This sorting algorithm is very efficient.
                </li>
                <li>
                    <b>Memory Usage</b> - Memory usage is minimal because apart from what is necessary to hold the initial list of items to be sorted,
                    it needs no additional space to work
                </li>
                <li>
                    <b>Simplicity</b> – It is simpler to understand than other equally efficient sorting algorithms because it does not use advanced
                    computer science concepts such as recursion
                </li>
            </ul>
            <h4>Disadvantages of Heapsort <sup>1</sup></h4>
            <ul>
                <li><b>Costly</b> – Heap sort is costly.</li>
                <li>
                    <b>Unstable</b> - Heap sort is unstable. This algorithm is not stable because the operations that are performed in a heap can
                    change the relative ordering of the equivalent keys.
                </li>
                <li><b>Efficient</b> – Heap Sort are not very efficient when working with highly complex data.</li>
            </ul>
            <h4>Applications of Heapsort <sup>1</sup></h4>
            <ul>
                <li>Heapsort is mainly used in hybrid algorithms like the IntroSort</li>
                <li>Sort a nearly sorted (or K sorted) array</li>
                <li>k largest(or smallest) elements in an array</li>
            </ul>
            <p>
                The heap sort algorithm has limited uses because Quicksort and Mergesort are better in practice. Nevertheless, the Heap data structure
                itself is enormously used.
            </p>
            <p style="color: rgba(0, 0, 0, 0)">.</p>
            <p>
                <sup>1</sup> Explanations in this section are from: Heap Sort. (2023, März 16). GeeksforGeeks.
                <a href="https://www.geeksforgeeks.org/heap-sort/">https://www.geeksforgeeks.org/heap-sort/</a> (last accessed: 20.03.2023)
            </p>
            <p>
                <sup>2</sup> Explanations in this section are from: Heap Sort Algorithm: Explanation, Implementation, and Complexity. (n.d.).
                Interview Kickstart.
                <a href="https://www.interviewkickstart.com/learn/heap-sort">https://www.interviewkickstart.com/learn/heap-sort</a> (last accessed:
                20.03.2023)
            </p>
        </template>

        <template id="dijkstra-popup-content">
            <h2>Dijkstra Visualization</h2>
            <h3>General</h3>
            <p>
                This is an interactive visualization of the Dijkstra Algorithm. On the left side is the graph which can be altered by adding and
                deleting nodes and edges. To start the algorithm, select a node as the starting node and press the start button. <br />
                The algorithm will then run and the table on the right side will be updated with the current shortest path to each node. The
                pseudocode shown below the table will highlight the corresponding lines of code. <br />
                The slider and the buttons at the bottom as well as the arrow keys can be used to step through the algorithm.
            </p>
            <h3>The Dijkstra Algorithm</h3>
            <h4>Purpose and Use Cases <sup>1</sup></h4>
            <p>
                With Dijkstra's Algorithm, you can find the shortest path between nodes in a graph. Particularly, you can find the shortest path from
                a node (called the "source node") to all other nodes in the graph, producing a shortest-path tree. This algorithm is used in GPS
                devices to find the shortest path between the current location and the destination. It has broad applications in industry, specially
                in domains that require modeling networks.
            </p>
            <h4>Basics <sup>1</sup></h4>
            <ul>
                <li>
                    Dijkstra's Algorithm basically starts at the node that you choose (the source node) and it analyzes the graph to find the shortest
                    path between that node and all the other nodes in the graph.
                </li>
                <li>
                    The algorithm keeps track of the currently known shortest distance from each node to the source node and it updates these values
                    if it finds a shorter path.
                </li>
                <li>
                    Once the algorithm has found the shortest path between the source node and another node, that node is marked as "visited" and
                    added to the path.
                </li>
                <li>
                    The process continues until all the nodes in the graph have been added to the path. This way, we have a path that connects the
                    source node to all other nodes following the shortest path possible to reach each node.
                </li>
            </ul>
            <h4>Requirements <sup>1</sup></h4>
            <p>
                Dijkstra's Algorithm can only work with graphs that have positive weights. This is because, during the process, the weights of the
                edges have to be added to find the shortest path. If there is a negative weight in the graph, then the algorithm will not work
                properly. Once a node has been marked as "visited", the current path to that node is marked as the shortest path to reach that node.
                And negative weights can alter this if the total weight can be decremented after this step has occurred.
            </p>
            <h4>Time Complexity <sup>2</sup></h4>
            <p>
                Time complexity of Dijkstra's algorithm is O(V<sup>2</sup>) where V is the number of vertices in the graph. It can be explained as
                below:
            </p>
            <ol>
                <li>
                    First thing we need to do is find the unvisited vertex with the smallest path. For that we require O(V) time as we need check all
                    the vertices.
                </li>
                <li>
                    Now for each vertex selected as above, we need to relax its neighbours which means to update each neighbours path to the smaller
                    value between its current path or to the newly found. The time required to relax one neighbour comes out to be of order of O(1)
                    (constant time).
                </li>
                <li>
                    For each vertex we need to relax all of its neighbours, and a vertex can have at most V-1 neighbours, so the time required to
                    update all neighbours of a vertex comes out to be [O(V) * O(1)] = O(V)
                </li>
            </ol>
            <p>So now following the above conditions, we get:</p>
            <ul>
                <li>Time for visiting all vertices <b>= O(V)</b></li>
                <li>Time required for processing one vertex <b>= O(V)</b></li>
                <li>Time required for visiting and processing all the vertices <b>= O(V) * O(V) = O(V<sup>2</sup>)</b></li>
            </ul>
            <p style="color: rgba(0, 0, 0, 0)">.</p>
            <p>
                <sup>1</sup> Explanations in this section are from: Navone, E. C. (2020, September 28). Dijkstra’s Shortest Path Algorithm—A Detailed
                and Visual Introduction. FreeCodeCamp.Org.
                <a href="https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/"
                    >https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/</a
                >
                (last accessed: 20.03.2023)
            </p>
            <p>
                <sup>2</sup> Explanations in this section are from: Pandey, M. (2021, December 20). Dijkstra Algorithm. Scaler Topics.
                <a href="https://www.scaler.com/topics/data-structures/dijkstra-algorithm/"
                    >https://www.scaler.com/topics/data-structures/dijkstra-algorithm/</a
                >
                (last accessed: 20.03.2023)
            </p>
        </template>

        <template id="graph-control-explanations">
            <style>
                p {
                    margin: 0 0 5px 0;
                }
                b {
                    margin: 0 8px 5px 0;
                }
                kbd {
                    background-color: #eee;
                    border-radius: 3px;
                    border: 1px solid #b4b4b4;
                    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2), 0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
                    color: #333;
                    display: inline-block;
                    font-size: 0.85em;
                    font-weight: 700;
                    line-height: 1;
                    padding: 2px 4px;
                    white-space: nowrap;
                }
            </style>
            <b>Select a Node:</b>
            <p>Click on a node until the color changes</p>
            <b>Add a Node:</b>
            <p>Hold <kbd>Shift</kbd> and click on the canvas</p>
            <b>Delete a Node:</b>
            <p>Select a node and press <kbd>← Backspace</kbd> or <kbd>Delete</kbd></p>
            <b>Add an Edge:</b>
            <p>
                Hold <kbd>Shift</kbd> and drag from one node to another node, to add an undirected edge add a second edge in the other direction
                between the nodes
            </p>
            <b>Change Edge Weight:</b>
            <p>Hold <kbd>Shift</kbd> and click on an edge</p>
            <b>Delete an Edge:</b>
            <p>Select an edge and press <kbd>← Backspace</kbd> or <kbd>Delete</kbd></p>
        </template>

        <!-- js entrypoint -->
        <script type="module" src="/static/js/index.js"></script>
    </body>
</html>
